from requirements import Requirements
from system import System
import control.matlab as mat


class Optimizer:
    """Creates an interface for the use of different optimization algorithms.
    """
    def __init__(self, optimizer: callable, initial_guess: tuple) -> None:
        """

        Args:
            optimizer (callable): minimizer function
            initial_guess (tuple): initial parameter values for the optimizer
        """
        self.optimizer = optimizer
        self.initial_guess = initial_guess
        self.loss_history = [] # objetive function values along optimization iterations

    def restart(self, optimizer, initial_guess: tuple) -> None:
        """clears the loss history and stores new instance of optimizer with new initial guess

        Args:
            optimizer (callable): minimizer function
            initial_guess (tuple): initial parameter values for the optimizer
        """
        self.optimizer = optimizer
        self.initial_guess = initial_guess
        self.loss_history.clear()

    def ND_log_loss(self, sol):
        """ logs the loss along optimization iterations based on the scipy nelder mead interface

        Args:
            sol (OptimizedSolution): intermidiate solution generated by scipy minimize utility
        """
        self.loss_history.append(self.J(sol))

    def cma_log_loss(self, es):
        """ logs the loss along optimization iterations based on the pycma interface

        Args:
            es (CMAEvolutionStrategy): cma object that stores intermediate optimization results
        """
        self.loss_history.append(es.best.f)

    def minimize(self, reqs: Requirements, system: System):
        """minimize objective function generated based on the requirements
           and the system transfer functions.

           The system's controller gains are updated in-place.

        Args:
            reqs (Requirements): requirements.
            system (System): system object containing the transfer functions.
        """
        self.make_obj_func(reqs, system)
        self.optimizer(self.J, *self.initial_guess)

    def make_obj_func(self, reqs: Requirements, system: System) -> None:
        """generates the objective function of the optimizer based on the 
            requirements' bandwidth, phase margin, and their respective tolerances.

            The loss function is of a quadratic error type.

        Args:
            reqs (Requirements): requirements.
            system (System): object containing the transfer functions from 
            which are extracted current bandwidth and phase margin.
        """
        def J(x):
            system.update_controler(x) # in-place update
            return  (
                    (mat.bandwidth(system.Gf) - reqs.wb - reqs.delta_wb)**2 
                    +(mat.margin(system.Ga)[1] - reqs.pm - reqs.delta_pm)**2
                    )
        self.J = J
        